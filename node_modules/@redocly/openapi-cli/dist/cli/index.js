#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _commander = _interopRequireDefault(require("commander"));

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var chockidar = _interopRequireWildcard(require("chokidar"));

var _redocly = _interopRequireDefault(require("../redocly"));

var _utils = require("./utils");

var _validate = require("../validate");

var _bundle = require("../bundle");

var _utils2 = require("../utils");

var _outputMessages = require("./outputMessages");

var _config = require("../config");

var _previewDocs = _interopRequireDefault(require("../preview-docs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const program = new _commander.default.Command();

const validateFile = async (filePath, options, cmdObj) => {
  let result;

  if (!_fs.default.existsSync(filePath) && (0, _utils2.isFullyQualifiedUrl)(filePath)) {
    process.stdout.write('Will validate from URL\n');
    result = await (0, _validate.validateFromUrl)(filePath, options);
  } else {
    result = await (0, _validate.validateFromFile)(filePath, options);
  }

  const resultStats = (0, _outputMessages.outputMessages)(result, cmdObj);
  const {
    totalErrors,
    totalWarnings
  } = resultStats;
  process.stdout.write(`${_chalk.default.blueBright(filePath)} results. Errors: ${totalErrors}, warnings: ${totalWarnings}\n`);
  return {
    errors: resultStats.totalErrors,
    warnings: resultStats.totalWarnings
  };
};

const cli = () => {
  const f = _fs.default.readFileSync(`${__dirname}/../package.json`, 'utf-8');

  const {
    version
  } = JSON.parse(f);
  program.version(version, '-v, --version', 'Output current version of the OpenAPI CLI.');
  program.command('registry:login').description('Login to the Redoc.ly API Registry with access token').option('-p, --prompt', 'Ask for credentials instead of looking them in the .env or enviroment variables').action(async () => {
    const clientToken = await (0, _utils.promptUser)(_chalk.default.green(`\n  ðŸ”‘ Copy your access token from ${_chalk.default.blue(`https://app.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/profile`)} and paste it below`));
    const client = new _redocly.default();
    client.login(clientToken);
  });
  program.command('registry:logout').description('Clear stored credentials for Redoc.ly API Registry').action(async () => {
    const client = new _redocly.default();
    client.logout();
  });
  program.command('bundle [entryPoints...]').description('Create a bundle using <entryPoint> as a root document.').option('-o, --output <outputName>', 'Filename or folder for the bundle.').option('--short', 'Reduce output in case of bundling errors.').option('--ext <ext>', 'Output extension: json, yaml or yml').option('-f, --force', 'Produce bundle output file even if validation errors were encountered').action(async (entryPoints, cmdObj) => {
    if (cmdObj.ext && ['yaml', 'yml', 'json'].indexOf(cmdObj.ext) === -1) {
      process.stdout.write('Unsupported value for --ext option. Supported values are: yaml, yml or json');
      process.exit(1);
    }

    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    const isOutputDir = cmdObj.output && !(0, _path.extname)(cmdObj.output);
    const ext = cmdObj.ext || (0, _path.extname)(cmdObj.output || '').substring(1) || 'yaml';
    const dir = isOutputDir ? cmdObj.output : (0, _path.dirname)(cmdObj.output || '');
    const results = {
      errors: 0,
      warnings: 0
    };

    for (const entryPoint of entryPoints) {
      let output;

      if (cmdObj.output) {
        const fileName = isOutputDir ? (0, _path.basename)(entryPoint, (0, _path.extname)(entryPoint)) : (0, _path.basename)(cmdObj.output, `.${ext}`);
        output = (0, _path.join)(dir, `${fileName}.${ext}`);
      }

      const bundlingStatus = await (0, _bundle.bundleToFile)(entryPoint, output, cmdObj.force);
      const resultStats = (0, _outputMessages.outputMessages)(bundlingStatus, cmdObj);

      if (resultStats.totalErrors === 0) {
        // we do not want to output anything to stdout if it's being piped.
        if (output) {
          process.stdout.write(`Created a bundle for ${entryPoint} at ${output}\n`);
        }
      } else {
        if (cmdObj.force) {
          process.stderr.write(`Created a bundle for ${entryPoint} at ${output}. Errors ignored because of --force\n`);
        } else {
          process.stderr.write(`Errors encountered while bundling ${entryPoint}: bundle not created (use --force to ignore errors)\n`);
        }

        results.errors += resultStats.totalErrors;
        results.warnings += resultStats.totalWarnings;
      }
    }

    process.exit(results.errors === 0 || cmdObj.force ? 0 : 1);
  });
  program.command('validate [entryPoints...]').description('Validate given OpenAPI 3 definition file.').option('--short', 'Reduce output to required minimun.').option('--no-frame', 'Print no codeframes with errors.').option('--config <path>', 'Specify custom yaml or json config').action(async (entryPoints, cmdObj) => {
    const options = {};
    const results = {
      errors: 0,
      warnings: 0
    };
    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    options.codeframes = cmdObj.frame;
    if (cmdObj.config) options.configPath = cmdObj.config;

    for (let i = 0; i < entryPoints.length; i++) {
      (0, _outputMessages.printValidationHeader)(entryPoints[i]);
      const msgs = await validateFile(entryPoints[i], options, cmdObj);
      results.errors += msgs.errors;
      results.warnings += msgs.warnings;
    }

    if (entryPoints.length > 1) {
      process.stdout.write(`Total results. Errors: ${results.errors}, warnings: ${results.warnings}\n`);
    }

    process.exit(results.errors > 0 ? 1 : 0);
  });

  function myParseInt(value) {
    return parseInt(value, 10);
  }

  program.command('preview-docs [entryPoint]').description('Preview API Reference docs for the specified entrypoint OAS definition').option('-p, --port <value>', 'Preview port', myParseInt, 8080).action(async (entryPoint, cmdObj) => {
    const output = 'dist/openapi.yaml';
    let config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign, prefer-destructuring

    entryPoint = (0, _config.getFallbackEntryPointsOrExit)(entryPoint ? [entryPoint] : [], config)[0];
    let cachedBundle;
    const deps = new Set();

    async function getBundle() {
      return cachedBundle;
    }

    async function updateBundle() {
      process.stdout.write('\nBundling...\n\n');
      const {
        bundle: openapiBundle,
        result,
        fileDependencies
      } = await (0, _bundle.bundle)(entryPoint, output, {
        lint: {
          codeframes: false
        }
      });
      const removed = [...deps].filter(x => !fileDependencies.has(x));
      watcher.unwatch(removed);
      watcher.add([...fileDependencies]);
      deps.clear();
      fileDependencies.forEach(deps.add, deps);
      const resultStats = (0, _outputMessages.outputMessages)(result, {
        short: true
      });

      if (resultStats.totalErrors === 0) {
        process.stdout.write(resultStats.totalErrors === 0 ? `Created a bundle for ${entryPoint} ${resultStats.totalWarnings > 0 ? 'with warnings' : 'successfully'}\n` : _chalk.default.yellow(`Created a bundle for ${entryPoint} with errors. Docs may be broken or not accurate\n`));
      }

      return openapiBundle;
    }

    setImmediate(() => {
      cachedBundle = updateBundle();
    }); // initial cache

    const hotClients = await (0, _previewDocs.default)(cmdObj.port, {
      getBundle,
      getOptions: () => config.referenceDocs
    });
    const watcher = chockidar.watch([entryPoint, config.configPath], {
      disableGlobbing: true,
      ignoreInitial: true
    });
    const debouncedUpdatedeBundle = (0, _utils2.debounce)(async () => {
      cachedBundle = updateBundle();
      await cachedBundle;
      hotClients.broadcast('{"type": "reload", "bundle": true}');
    }, 2000);

    const changeHandler = async (type, file) => {
      process.stdout.write(`${_chalk.default.green('watch')} ${type} ${_chalk.default.blue(file)}\n`);

      if (file === config.configPath) {
        config = (0, _config.getConfig)({
          configPath: file
        });
        hotClients.broadcast(JSON.stringify({
          type: 'reload'
        }));
        return;
      }

      debouncedUpdatedeBundle();
    };

    watcher.on('change', changeHandler.bind(undefined, 'changed'));
    watcher.on('add', changeHandler.bind(undefined, 'added'));
    watcher.on('unlink', changeHandler.bind(undefined, 'removed'));
    watcher.on('ready', () => {
      process.stdout.write(`\n  ðŸ‘€  Watching ${_chalk.default.blue(entryPoint)} and all related resources for changes\n`);
    });
  });
  program.on('command:*', () => {
    process.stderr.write(`\nUnknown command ${program.args.join(' ')}\n\n`);
    program.outputHelp();
  });
  if (process.argv.length === 2) process.argv.push('-h');
  program.parse(process.argv);
};

var _default = cli;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvaW5kZXguanMiXSwibmFtZXMiOlsicHJvZ3JhbSIsImNvbW1hbmRlciIsIkNvbW1hbmQiLCJ2YWxpZGF0ZUZpbGUiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJjbWRPYmoiLCJyZXN1bHQiLCJmcyIsImV4aXN0c1N5bmMiLCJwcm9jZXNzIiwic3Rkb3V0Iiwid3JpdGUiLCJyZXN1bHRTdGF0cyIsInRvdGFsRXJyb3JzIiwidG90YWxXYXJuaW5ncyIsImNoYWxrIiwiYmx1ZUJyaWdodCIsImVycm9ycyIsIndhcm5pbmdzIiwiY2xpIiwiZiIsInJlYWRGaWxlU3luYyIsIl9fZGlybmFtZSIsInZlcnNpb24iLCJKU09OIiwicGFyc2UiLCJjb21tYW5kIiwiZGVzY3JpcHRpb24iLCJvcHRpb24iLCJhY3Rpb24iLCJjbGllbnRUb2tlbiIsImdyZWVuIiwiYmx1ZSIsImVudiIsIlJFRE9DTFlfRE9NQUlOIiwiY2xpZW50IiwiUmVkb2NseUNsaWVudCIsImxvZ2luIiwibG9nb3V0IiwiZW50cnlQb2ludHMiLCJleHQiLCJpbmRleE9mIiwiZXhpdCIsImNvbmZpZyIsImlzT3V0cHV0RGlyIiwib3V0cHV0Iiwic3Vic3RyaW5nIiwiZGlyIiwicmVzdWx0cyIsImVudHJ5UG9pbnQiLCJmaWxlTmFtZSIsImJ1bmRsaW5nU3RhdHVzIiwiZm9yY2UiLCJzdGRlcnIiLCJjb2RlZnJhbWVzIiwiZnJhbWUiLCJjb25maWdQYXRoIiwiaSIsImxlbmd0aCIsIm1zZ3MiLCJteVBhcnNlSW50IiwidmFsdWUiLCJwYXJzZUludCIsImNhY2hlZEJ1bmRsZSIsImRlcHMiLCJTZXQiLCJnZXRCdW5kbGUiLCJ1cGRhdGVCdW5kbGUiLCJidW5kbGUiLCJvcGVuYXBpQnVuZGxlIiwiZmlsZURlcGVuZGVuY2llcyIsImxpbnQiLCJyZW1vdmVkIiwiZmlsdGVyIiwieCIsImhhcyIsIndhdGNoZXIiLCJ1bndhdGNoIiwiYWRkIiwiY2xlYXIiLCJmb3JFYWNoIiwic2hvcnQiLCJ5ZWxsb3ciLCJzZXRJbW1lZGlhdGUiLCJob3RDbGllbnRzIiwicG9ydCIsImdldE9wdGlvbnMiLCJyZWZlcmVuY2VEb2NzIiwiY2hvY2tpZGFyIiwid2F0Y2giLCJkaXNhYmxlR2xvYmJpbmciLCJpZ25vcmVJbml0aWFsIiwiZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUiLCJicm9hZGNhc3QiLCJjaGFuZ2VIYW5kbGVyIiwidHlwZSIsImZpbGUiLCJzdHJpbmdpZnkiLCJvbiIsImJpbmQiLCJ1bmRlZmluZWQiLCJhcmdzIiwiam9pbiIsIm91dHB1dEhlbHAiLCJhcmd2IiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBR0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUEsTUFBTUEsT0FBTyxHQUFHLElBQUlDLG1CQUFVQyxPQUFkLEVBQWhCOztBQUVBLE1BQU1DLFlBQVksR0FBRyxPQUFPQyxRQUFQLEVBQWlCQyxPQUFqQixFQUEwQkMsTUFBMUIsS0FBcUM7QUFDeEQsTUFBSUMsTUFBSjs7QUFFQSxNQUFJLENBQUNDLFlBQUdDLFVBQUgsQ0FBY0wsUUFBZCxDQUFELElBQTRCLGlDQUFvQkEsUUFBcEIsQ0FBaEMsRUFBK0Q7QUFDN0RNLElBQUFBLE9BQU8sQ0FBQ0MsTUFBUixDQUFlQyxLQUFmLENBQXFCLDBCQUFyQjtBQUNBTCxJQUFBQSxNQUFNLEdBQUcsTUFBTSwrQkFBZ0JILFFBQWhCLEVBQTBCQyxPQUExQixDQUFmO0FBQ0QsR0FIRCxNQUdPO0FBQ0xFLElBQUFBLE1BQU0sR0FBRyxNQUFNLGdDQUFpQkgsUUFBakIsRUFBMkJDLE9BQTNCLENBQWY7QUFDRDs7QUFDRCxRQUFNUSxXQUFXLEdBQUcsb0NBQWVOLE1BQWYsRUFBdUJELE1BQXZCLENBQXBCO0FBRUEsUUFBTTtBQUFFUSxJQUFBQSxXQUFGO0FBQWVDLElBQUFBO0FBQWYsTUFBaUNGLFdBQXZDO0FBQ0FILEVBQUFBLE9B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QUFiLENBQWtCLEdBQWxCLENBQXVCLE1BQWpFO0FBQ0F2RyxJQUFBQSxPQUFPLENBQUN3RyxVQUFSO0FBQ0QsR0FIRDtBQUtBLE1BQUk5RixPQUFPLENBQUMrRixJQUFSLENBQWE5QyxNQUFiLEtBQXdCLENBQTVCLEVBQStCakQsT0FBTyxDQUFDK0YsSUFBUixDQUFhQyxJQUFiLENBQWtCLElBQWxCO0FBRS9CMUcsRUFBQUEsT0FBTyxDQUFDMEIsS0FBUixDQUFjaEIsT0FBTyxDQUFDK0YsSUFBdEI7QUFDRCxDQTNORDs7ZUE2TmVyRixHIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IGNvbW1hbmRlciBmcm9tICdjb21tYW5kZXInO1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHtcbiAgam9pbiwgYmFzZW5hbWUsIGRpcm5hbWUsIGV4dG5hbWUsXG59IGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY2hvY2tpZGFyIGZyb20gJ2Nob2tpZGFyJztcblxuaW1wb3J0IFJlZG9jbHlDbGllbnQgZnJvbSAnLi4vcmVkb2NseSc7XG5pbXBvcnQgeyBwcm9tcHRVc2VyIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUZyb21GaWxlLCB2YWxpZGF0ZUZyb21VcmwgfSBmcm9tICcuLi92YWxpZGF0ZSc7XG5pbXBvcnQgeyBidW5kbGUsIGJ1bmRsZVRvRmlsZSB9IGZyb20gJy4uL2J1bmRsZSc7XG5cbmltcG9ydCB7IGlzRnVsbHlRdWFsaWZpZWRVcmwsIGRlYm91bmNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBvdXRwdXRNZXNzYWdlcywgcHJpbnRWYWxpZGF0aW9uSGVhZGVyIH0gZnJvbSAnLi9vdXRwdXRNZXNzYWdlcyc7XG5pbXBvcnQgeyBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0LCBnZXRDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQgc3RhcnRQcmV2aWV3U2VydmVyIGZyb20gJy4uL3ByZXZpZXctZG9jcyc7XG5cbmNvbnN0IHByb2dyYW0gPSBuZXcgY29tbWFuZGVyLkNvbW1hbmQoKTtcblxuY29uc3QgdmFsaWRhdGVGaWxlID0gYXN5bmMgKGZpbGVQYXRoLCBvcHRpb25zLCBjbWRPYmopID0+IHtcbiAgbGV0IHJlc3VsdDtcblxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpICYmIGlzRnVsbHlRdWFsaWZpZWRVcmwoZmlsZVBhdGgpKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1dpbGwgdmFsaWRhdGUgZnJvbSBVUkxcXG4nKTtcbiAgICByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZUZyb21VcmwoZmlsZVBhdGgsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlRnJvbUZpbGUoZmlsZVBhdGgsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IHJlc3VsdFN0YXRzID0gb3V0cHV0TWVzc2FnZXMocmVzdWx0LCBjbWRPYmopO1xuXG4gIGNvbnN0IHsgdG90YWxFcnJvcnMsIHRvdGFsV2FybmluZ3MgfSA9IHJlc3VsdFN0YXRzO1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShcbiAgICBgJHtjaGFsay5ibHVlQnJpZ2h0KGZpbGVQYXRoKX0gcmVzdWx0cy4gRXJyb3JzOiAke3RvdGFsRXJyb3JzfSwgd2FybmluZ3M6ICR7dG90YWxXYXJuaW5nc31cXG5gLFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgZXJyb3JzOiByZXN1bHRTdGF0cy50b3RhbEVycm9ycyxcbiAgICB3YXJuaW5nczogcmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncyxcbiAgfTtcbn07XG5cbmNvbnN0IGNsaSA9ICgpID0+IHtcbiAgY29uc3QgZiA9IGZzLnJlYWRGaWxlU3luYyhgJHtfX2Rpcm5hbWV9Ly4uL3BhY2thZ2UuanNvbmAsICd1dGYtOCcpO1xuICBjb25zdCB7IHZlcnNpb24gfSA9IEpTT04ucGFyc2UoZik7XG5cbiAgcHJvZ3JhbVxuICAgIC52ZXJzaW9uKHZlcnNpb24sICctdiwgLS12ZXJzaW9uJywgJ091dHB1dCBjdXJyZW50IHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgQ0xJLicpO1xuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgncmVnaXN0cnk6bG9naW4nKVxuICAgIC5kZXNjcmlwdGlvbignTG9naW4gdG8gdGhlIFJlZG9jLmx5IEFQSSBSZWdpc3RyeSB3aXRoIGFjY2VzcyB0b2tlbicpXG4gICAgLm9wdGlvbignLXAsIC0tcHJvbXB0JywgJ0FzayBmb3IgY3JlZGVudGlhbHMgaW5zdGVhZCBvZiBsb29raW5nIHRoZW0gaW4gdGhlIC5lbnYgb3IgZW52aXJvbWVudCB2YXJpYWJsZXMnKVxuICAgIC5hY3Rpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50VG9rZW4gPSBhd2FpdCBwcm9tcHRVc2VyKFxuICAgICAgICBjaGFsay5ncmVlbihgXFxuICDwn5SRIENvcHkgeW91ciBhY2Nlc3MgdG9rZW4gZnJvbSAke2NoYWxrLmJsdWUoYGh0dHBzOi8vYXBwLiR7cHJvY2Vzcy5lbnYuUkVET0NMWV9ET01BSU4gfHwgJ3JlZG9jLmx5J30vcHJvZmlsZWApfSBhbmQgcGFzdGUgaXQgYmVsb3dgKSxcbiAgICAgICk7XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgUmVkb2NseUNsaWVudCgpO1xuICAgICAgY2xpZW50LmxvZ2luKGNsaWVudFRva2VuKTtcbiAgICB9KTtcblxuICBwcm9ncmFtXG4gICAgLmNvbW1hbmQoJ3JlZ2lzdHJ5OmxvZ291dCcpXG4gICAgLmRlc2NyaXB0aW9uKCdDbGVhciBzdG9yZWQgY3JlZGVudGlhbHMgZm9yIFJlZG9jLmx5IEFQSSBSZWdpc3RyeScpXG4gICAgLmFjdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgUmVkb2NseUNsaWVudCgpO1xuICAgICAgY2xpZW50LmxvZ291dCgpO1xuICAgIH0pO1xuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgnYnVuZGxlIFtlbnRyeVBvaW50cy4uLl0nKVxuICAgIC5kZXNjcmlwdGlvbignQ3JlYXRlIGEgYnVuZGxlIHVzaW5nIDxlbnRyeVBvaW50PiBhcyBhIHJvb3QgZG9jdW1lbnQuJylcbiAgICAub3B0aW9uKCctbywgLS1vdXRwdXQgPG91dHB1dE5hbWU+JywgJ0ZpbGVuYW1lIG9yIGZvbGRlciBmb3IgdGhlIGJ1bmRsZS4nKVxuICAgIC5vcHRpb24oJy0tc2hvcnQnLCAnUmVkdWNlIG91dHB1dCBpbiBjYXNlIG9mIGJ1bmRsaW5nIGVycm9ycy4nKVxuICAgIC5vcHRpb24oJy0tZXh0IDxleHQ+JywgJ091dHB1dCBleHRlbnNpb246IGpzb24sIHlhbWwgb3IgeW1sJylcbiAgICAub3B0aW9uKCctZiwgLS1mb3JjZScsICdQcm9kdWNlIGJ1bmRsZSBvdXRwdXQgZmlsZSBldmVuIGlmIHZhbGlkYXRpb24gZXJyb3JzIHdlcmUgZW5jb3VudGVyZWQnKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnRzLCBjbWRPYmopID0+IHtcbiAgICAgIGlmIChjbWRPYmouZXh0ICYmIFsneWFtbCcsICd5bWwnLCAnanNvbiddLmluZGV4T2YoY21kT2JqLmV4dCkgPT09IC0xKSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKFxuICAgICAgICAgICdVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgLS1leHQgb3B0aW9uLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZTogeWFtbCwgeW1sIG9yIGpzb24nLFxuICAgICAgICApO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbmZpZyh7fSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIGVudHJ5UG9pbnRzID0gZ2V0RmFsbGJhY2tFbnRyeVBvaW50c09yRXhpdChlbnRyeVBvaW50cywgY29uZmlnKTtcblxuICAgICAgY29uc3QgaXNPdXRwdXREaXIgPSBjbWRPYmoub3V0cHV0ICYmICFleHRuYW1lKGNtZE9iai5vdXRwdXQpO1xuICAgICAgY29uc3QgZXh0ID0gY21kT2JqLmV4dCB8fCBleHRuYW1lKGNtZE9iai5vdXRwdXQgfHwgJycpLnN1YnN0cmluZygxKSB8fCAneWFtbCc7XG4gICAgICBjb25zdCBkaXIgPSBpc091dHB1dERpciA/IGNtZE9iai5vdXRwdXQgOiBkaXJuYW1lKGNtZE9iai5vdXRwdXQgfHwgJycpO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0ge1xuICAgICAgICBlcnJvcnM6IDAsXG4gICAgICAgIHdhcm5pbmdzOiAwLFxuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBlbnRyeVBvaW50IG9mIGVudHJ5UG9pbnRzKSB7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIGlmIChjbWRPYmoub3V0cHV0KSB7XG4gICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBpc091dHB1dERpclxuICAgICAgICAgICAgPyBiYXNlbmFtZShlbnRyeVBvaW50LCBleHRuYW1lKGVudHJ5UG9pbnQpKVxuICAgICAgICAgICAgOiBiYXNlbmFtZShjbWRPYmoub3V0cHV0LCBgLiR7ZXh0fWApO1xuICAgICAgICAgIG91dHB1dCA9IGpvaW4oZGlyLCBgJHtmaWxlTmFtZX0uJHtleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidW5kbGluZ1N0YXR1cyA9IGF3YWl0IGJ1bmRsZVRvRmlsZShlbnRyeVBvaW50LCBvdXRwdXQsIGNtZE9iai5mb3JjZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdFN0YXRzID0gb3V0cHV0TWVzc2FnZXMoYnVuZGxpbmdTdGF0dXMsIGNtZE9iaik7XG5cbiAgICAgICAgaWYgKHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzID09PSAwKSB7XG4gICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gb3V0cHV0IGFueXRoaW5nIHRvIHN0ZG91dCBpZiBpdCdzIGJlaW5nIHBpcGVkLlxuICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9IGF0ICR7b3V0cHV0fVxcbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY21kT2JqLmZvcmNlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcbiAgICAgICAgICAgICAgYENyZWF0ZWQgYSBidW5kbGUgZm9yICR7ZW50cnlQb2ludH0gYXQgJHtvdXRwdXR9LiBFcnJvcnMgaWdub3JlZCBiZWNhdXNlIG9mIC0tZm9yY2VcXG5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXG4gICAgICAgICAgICAgIGBFcnJvcnMgZW5jb3VudGVyZWQgd2hpbGUgYnVuZGxpbmcgJHtlbnRyeVBvaW50fTogYnVuZGxlIG5vdCBjcmVhdGVkICh1c2UgLS1mb3JjZSB0byBpZ25vcmUgZXJyb3JzKVxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHRzLmVycm9ycyArPSByZXN1bHRTdGF0cy50b3RhbEVycm9ycztcbiAgICAgICAgICByZXN1bHRzLndhcm5pbmdzICs9IHJlc3VsdFN0YXRzLnRvdGFsV2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZXhpdChyZXN1bHRzLmVycm9ycyA9PT0gMCB8fCBjbWRPYmouZm9yY2UgPyAwIDogMSk7XG4gICAgfSk7XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCd2YWxpZGF0ZSBbZW50cnlQb2ludHMuLi5dJylcbiAgICAuZGVzY3JpcHRpb24oJ1ZhbGlkYXRlIGdpdmVuIE9wZW5BUEkgMyBkZWZpbml0aW9uIGZpbGUuJylcbiAgICAub3B0aW9uKCctLXNob3J0JywgJ1JlZHVjZSBvdXRwdXQgdG8gcmVxdWlyZWQgbWluaW11bi4nKVxuICAgIC5vcHRpb24oJy0tbm8tZnJhbWUnLCAnUHJpbnQgbm8gY29kZWZyYW1lcyB3aXRoIGVycm9ycy4nKVxuICAgIC5vcHRpb24oJy0tY29uZmlnIDxwYXRoPicsICdTcGVjaWZ5IGN1c3RvbSB5YW1sIG9yIGpzb24gY29uZmlnJylcbiAgICAuYWN0aW9uKGFzeW5jIChlbnRyeVBvaW50cywgY21kT2JqKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICBjb25zdCByZXN1bHRzID0ge1xuICAgICAgICBlcnJvcnM6IDAsXG4gICAgICAgIHdhcm5pbmdzOiAwLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKHt9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZW50cnlQb2ludHMgPSBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0KGVudHJ5UG9pbnRzLCBjb25maWcpO1xuXG4gICAgICBvcHRpb25zLmNvZGVmcmFtZXMgPSBjbWRPYmouZnJhbWU7XG4gICAgICBpZiAoY21kT2JqLmNvbmZpZykgb3B0aW9ucy5jb25maWdQYXRoID0gY21kT2JqLmNvbmZpZztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyeVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmludFZhbGlkYXRpb25IZWFkZXIoZW50cnlQb2ludHNbaV0pO1xuXG4gICAgICAgIGNvbnN0IG1zZ3MgPSBhd2FpdCB2YWxpZGF0ZUZpbGUoZW50cnlQb2ludHNbaV0sIG9wdGlvbnMsIGNtZE9iaik7XG4gICAgICAgIHJlc3VsdHMuZXJyb3JzICs9IG1zZ3MuZXJyb3JzO1xuICAgICAgICByZXN1bHRzLndhcm5pbmdzICs9IG1zZ3Mud2FybmluZ3M7XG4gICAgICB9XG4gICAgICBpZiAoZW50cnlQb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgVG90YWwgcmVzdWx0cy4gRXJyb3JzOiAke3Jlc3VsdHMuZXJyb3JzfSwgd2FybmluZ3M6ICR7cmVzdWx0cy53YXJuaW5nc31cXG5gKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZXhpdChyZXN1bHRzLmVycm9ycyA+IDAgPyAxIDogMCk7XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gbXlQYXJzZUludCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdwcmV2aWV3LWRvY3MgW2VudHJ5UG9pbnRdJylcbiAgICAuZGVzY3JpcHRpb24oJ1ByZXZpZXcgQVBJIFJlZmVyZW5jZSBkb2NzIGZvciB0aGUgc3BlY2lmaWVkIGVudHJ5cG9pbnQgT0FTIGRlZmluaXRpb24nKVxuICAgIC5vcHRpb24oJy1wLCAtLXBvcnQgPHZhbHVlPicsICdQcmV2aWV3IHBvcnQnLCBteVBhcnNlSW50LCA4MDgwKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnQsIGNtZE9iaikgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gJ2Rpc3Qvb3BlbmFwaS55YW1sJztcblxuICAgICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyh7fSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICBlbnRyeVBvaW50ID0gZ2V0RmFsbGJhY2tFbnRyeVBvaW50c09yRXhpdChlbnRyeVBvaW50ID8gW2VudHJ5UG9pbnRdIDogW10sIGNvbmZpZylbMF07XG5cbiAgICAgIGxldCBjYWNoZWRCdW5kbGU7XG4gICAgICBjb25zdCBkZXBzID0gbmV3IFNldCgpO1xuXG4gICAgICBhc3luYyBmdW5jdGlvbiBnZXRCdW5kbGUoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRCdW5kbGU7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUJ1bmRsZSgpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbkJ1bmRsaW5nLi4uXFxuXFxuJyk7XG4gICAgICAgIGNvbnN0IHsgYnVuZGxlOiBvcGVuYXBpQnVuZGxlLCByZXN1bHQsIGZpbGVEZXBlbmRlbmNpZXMgfSA9IGF3YWl0IGJ1bmRsZShlbnRyeVBvaW50LCBvdXRwdXQsIHtcbiAgICAgICAgICBsaW50OiB7XG4gICAgICAgICAgICBjb2RlZnJhbWVzOiBmYWxzZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZW1vdmVkID0gWy4uLmRlcHNdLmZpbHRlcigoeCkgPT4gIWZpbGVEZXBlbmRlbmNpZXMuaGFzKHgpKTtcbiAgICAgICAgd2F0Y2hlci51bndhdGNoKHJlbW92ZWQpO1xuICAgICAgICB3YXRjaGVyLmFkZChbLi4uZmlsZURlcGVuZGVuY2llc10pO1xuICAgICAgICBkZXBzLmNsZWFyKCk7XG4gICAgICAgIGZpbGVEZXBlbmRlbmNpZXMuZm9yRWFjaChkZXBzLmFkZCwgZGVwcyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhyZXN1bHQsIHsgc2hvcnQ6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzID09PSAwKSB7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgICByZXN1bHRTdGF0cy50b3RhbEVycm9ycyA9PT0gMFxuICAgICAgICAgICAgICA/IGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9ICR7cmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncyA+IDAgPyAnd2l0aCB3YXJuaW5ncycgOiAnc3VjY2Vzc2Z1bGx5J31cXG5gXG4gICAgICAgICAgICAgIDogY2hhbGsueWVsbG93KGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9IHdpdGggZXJyb3JzLiBEb2NzIG1heSBiZSBicm9rZW4gb3Igbm90IGFjY3VyYXRlXFxuYCksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcGVuYXBpQnVuZGxlO1xuICAgICAgfVxuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWNoZWRCdW5kbGUgPSB1cGRhdGVCdW5kbGUoKTtcbiAgICAgIH0pOyAvLyBpbml0aWFsIGNhY2hlXG5cbiAgICAgIGNvbnN0IGhvdENsaWVudHMgPSBhd2FpdCBzdGFydFByZXZpZXdTZXJ2ZXIoY21kT2JqLnBvcnQsIHtcbiAgICAgICAgZ2V0QnVuZGxlLFxuICAgICAgICBnZXRPcHRpb25zOiAoKSA9PiBjb25maWcucmVmZXJlbmNlRG9jcyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3YXRjaGVyID0gY2hvY2tpZGFyLndhdGNoKFtlbnRyeVBvaW50LCBjb25maWcuY29uZmlnUGF0aF0sIHtcbiAgICAgICAgZGlzYWJsZUdsb2JiaW5nOiB0cnVlLFxuICAgICAgICBpZ25vcmVJbml0aWFsOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRlYm91bmNlZFVwZGF0ZWRlQnVuZGxlID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjYWNoZWRCdW5kbGUgPSB1cGRhdGVCdW5kbGUoKTtcbiAgICAgICAgYXdhaXQgY2FjaGVkQnVuZGxlO1xuICAgICAgICBob3RDbGllbnRzLmJyb2FkY2FzdCgne1widHlwZVwiOiBcInJlbG9hZFwiLCBcImJ1bmRsZVwiOiB0cnVlfScpO1xuICAgICAgfSwgMjAwMCk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZUhhbmRsZXIgPSBhc3luYyAodHlwZSwgZmlsZSkgPT4ge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtjaGFsay5ncmVlbignd2F0Y2gnKX0gJHt0eXBlfSAke2NoYWxrLmJsdWUoZmlsZSl9XFxuYCk7XG4gICAgICAgIGlmIChmaWxlID09PSBjb25maWcuY29uZmlnUGF0aCkge1xuICAgICAgICAgIGNvbmZpZyA9IGdldENvbmZpZyh7IGNvbmZpZ1BhdGg6IGZpbGUgfSk7XG4gICAgICAgICAgaG90Q2xpZW50cy5icm9hZGNhc3QoSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAncmVsb2FkJyB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUoKTtcbiAgICAgIH07XG5cbiAgICAgIHdhdGNoZXIub24oJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIuYmluZCh1bmRlZmluZWQsICdjaGFuZ2VkJykpO1xuICAgICAgd2F0Y2hlci5vbignYWRkJywgY2hhbmdlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgJ2FkZGVkJykpO1xuICAgICAgd2F0Y2hlci5vbigndW5saW5rJywgY2hhbmdlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgJ3JlbW92ZWQnKSk7XG5cbiAgICAgIHdhdGNoZXIub24oJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxuICDwn5GAICBXYXRjaGluZyAke2NoYWxrLmJsdWUoZW50cnlQb2ludCl9IGFuZCBhbGwgcmVsYXRlZCByZXNvdXJjZXMgZm9yIGNoYW5nZXNcXG5gKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIHByb2dyYW0ub24oJ2NvbW1hbmQ6KicsICgpID0+IHtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgXFxuVW5rbm93biBjb21tYW5kICR7cHJvZ3JhbS5hcmdzLmpvaW4oJyAnKX1cXG5cXG5gKTtcbiAgICBwcm9ncmFtLm91dHB1dEhlbHAoKTtcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuYXJndi5sZW5ndGggPT09IDIpIHByb2Nlc3MuYXJndi5wdXNoKCctaCcpO1xuXG4gIHByb2dyYW0ucGFyc2UocHJvY2Vzcy5hcmd2KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsaTtcbiJdfQ==